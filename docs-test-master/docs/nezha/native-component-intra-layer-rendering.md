---
id: native-component-intra-layer-rendering
title: Intra-layer Rendering
sidebar_label: Intra-layer Rendering
hide_title: true
---

## What is「Intra-layer rendering」？

Let's first understand the rendering principle of the native component of the mini programs. The content of the mini programs is mostly rendered on the WebView. If the WebView is regarded as a separate layer, then the native components that come with the system are located at another higher level. The two levels are completely independent, so the relative level between native and non-native components cannot be controlled simply by using `z-index`. As shown in the figure below, non-native components are located in the WebView layer, and native components are located at another higher level:

![intra-layer-origin](https://static.devfdg.net/static/mono-static/docs-ui/img/intra-layer-origin.jpg)

`Intra-layer rendering` is to render native components directly to the WebView level through some methods, `Native component layer` no longer exists, The native component has now been directly mounted on the WebView node. You can use `Intra-layer rendering` native components almost like non-native components, For example, using `view` and `image` to overwrite native components, using `z-index` to specify the level of native components, and placing native components in containers such as `scroll-view`, `swiper`, and `movable-view`. `CSS` sets the style of native components, etc. The interface level after enabling `Intra-layer rendering` is shown below:

![intra-layer-update](https://static.devfdg.net/static/mono-static/docs-ui/img/intra-layer-update.jpg)

## 「Intra-layer rendering」principle

### iOS

> **WKWebView**: is a browser component provided after `iOS 8`. The iOS side uses `WKWebView` for rendering, and `WKWebView` uses a **layered method** for rendering internally. `WKWebView` will render the `Compositing Layer` (compositing layer) generated by the `WebKit` kernel into a `WKCompositingView` (a kind of  `native component`) on iOS.

>**Compositing Layer**: Native composite layer, the kernel generally renders the DOM nodes in multiple `webviews `to a `Compositing Layer`, so there is no one-to-one mapping relationship between the composite layer and DOM nodes.

>**WKChildScrollView**: A kind of `native component`. When the CSS property of a DOM node is set to `overflow: scroll` (lower version needs to be set at the same time `-webkit-overflow-scrolling: touch`), `WKWebView` will generate a `WKChildScrollView` for it, which has a mapping relationship with DOM nodes, this is a subclass of the native `UIScrollView`, which means that the scrolling in the `WebView` is actually carried by the real native scrolling component. 
>
>`WKWebView` does this to make the scrolling experience of `WebView` on iOS more smooth. Although `WKChildScrollView` is also a "native component", the `WebKit` kernel has already processed the hierarchical relationship between it and other DOM nodes, so you can directly use CSS to control the hierarchy without worrying about occlusion.

The `Intra-layer rendering` on the iOS side of the mini programs is also implemented based on `WKChildScrollView`. After the `native component` is attached, it will be directly mounted under the pre-created `WKChildScrollView` container. The general flow is as follows:

1. For the front end of the mini programs, create a DOM node in the webview and set its CSS property to `overflow: hidden` and `-webkit-overflow-scrolling: touch`. At the same time, a child node with a height equal to the node needs to be inserted inside, the WebKit kernel Will generate a `WKChildScrollView`. 

   And generate a **`six-digit instanceId`**, set it to the background color of the DOM node, and the background color **alpha value is fixed to `01`**. Background color format: `#(instanceId)01`;

   Sample code：

   ```html
   <div id="native-component">
     
   <!-- instanceId is 000001 -->
       <div style="background-color: #00000101; -webkit-overflow-scrolling: touch; overflow: scroll; position: absolute; width: 100%; height: 100%; top: 0px; left: 0px; background-position: initial initial; background-repeat: initial initial;">
           <div style="height: 100%; margin-top: 1px;"></div>
       </div>
   
   </div>
   ```

2. The front end calls `native-component-create` to notify the client to find the native `WKChildScrollView` component corresponding to the DOM node by recursive search;

3. Mount the `native component` to the `WKChildScrollView` node as its child View;

4. The WebKit kernel has processed the hierarchical relationship between `WKChildScrollView` and the corresponding DOM node.

![intra-layer-wkscrollview](https://static.devfdg.net/static/mono-static/docs-ui/img/intra-layer-wkscrollview.jpg)

Through the above process, the `native component` of the mini programs is inserted into the `WKChildScrollView`, which is the native `WKChildScrollView` node mapped from the DOM node created in step 1. At this point, modifying the style attributes of this DOM node will also be applied to the `native component`. Therefore, the `native components` of `Intra-layer rendering` behave the same as ordinary H5 components.

### Android



### Reference

[Wechat intra-layer rendering principle](https://developers.weixin.qq.com/community/develop/article/doc/000c4e433707c072c1793e56f5c813?page=1#comment-list)
